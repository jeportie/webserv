# Task ID: 2

# Title: Implement Event Loop with epoll()

# Status: done

# Dependencies: 1

# Priority: high

# Description: Create a non-blocking event loop using **epoll()** to handle multiple client connections simultaneously.

# Details:

Implement an `EventLoop` class that:

1. Uses `epoll_create1()`/`epoll_wait()` to monitor file descriptors for read/write readiness
2. Maintains a collection of active client connections
3. Handles events for server sockets (new connections) and client sockets (data ready, write ready)
4. Provides a clean interface for the main server loop

Pseudo-code:

```cpp
class EventLoop {
private:
    int                             _epollFd;           // epoll instance FD
    std::vector<struct epoll_event> _events;            // event buffer
    std::map<int, ClientConnection> clients;
    SocketManager&                  socket_manager;
    
public:
    EventLoop(SocketManager& sm);
    ~EventLoop();

    void addServerSocket(int server_socket);
    void addClientSocket(int client_socket, ClientConnection client);
    void modifyClientEvents(int client_socket, uint32_t events);
    void removeSocket(int socket_fd);
    void run(int timeout_ms = -1);

    // Event handlers
    void handleServerEvent(int server_socket);
    void handleClientReadEvent(int client_socket);
    void handleClientWriteEvent(int client_socket);
};

EventLoop::EventLoop(SocketManager& sm)
  : socket_manager(sm),
    _epollFd(epoll_create1(0)),
    _events(1024)
{
    if (_epollFd < 0) {
        throw std::runtime_error("Failed to create epoll instance");
    }
}

void EventLoop::addServerSocket(int server_socket) {
    struct epoll_event ev = {};
    ev.events = EPOLLIN;
    ev.data.fd = server_socket;
    epoll_ctl(_epollFd, EPOLL_CTL_ADD, server_socket, &ev);
}

void EventLoop::addClientSocket(int client_socket, ClientConnection client) {
    clients[client_socket] = std::move(client);
    struct epoll_event ev = {};
    ev.events = EPOLLIN | EPOLLET;     // edge-triggered read
    ev.data.fd = client_socket;
    epoll_ctl(_epollFd, EPOLL_CTL_ADD, client_socket, &ev);
}

void EventLoop::modifyClientEvents(int client_socket, uint32_t events) {
    struct epoll_event ev = {};
    ev.events = events;
    ev.data.fd = client_socket;
    epoll_ctl(_epollFd, EPOLL_CTL_MOD, client_socket, &ev);
}

void EventLoop::removeSocket(int socket_fd) {
    epoll_ctl(_epollFd, EPOLL_CTL_DEL, socket_fd, nullptr);
    clients.erase(socket_fd);
}

void EventLoop::run(int timeout_ms) {
    int ready = epoll_wait(_epollFd, _events.data(), _events.size(), timeout_ms);
    if (ready <= 0) return; // Timeout or error

    for (int i = 0; i < ready; ++i) {
        auto &ev = _events[i];
        int fd = ev.data.fd;

        if (is_server_socket(fd)) {
            if (ev.events & EPOLLIN) {
                handleServerEvent(fd);
            }
        } else {
            if (ev.events & EPOLLIN) {
                handleClientReadEvent(fd);
            }
            if (ev.events & EPOLLOUT) {
                handleClientWriteEvent(fd);
            }
            if (ev.events & (EPOLLERR | EPOLLHUP)) {
                removeSocket(fd);
            }
        }
    }
}
```

Implement the main server loop that initializes the `EventLoop` and continuously calls `run()`.

# Test Strategy:

1. Unit tests for `EventLoop` class methods
2. Test with a mock `epoll_wait()` implementation to verify correct event handling
3. Integration test with multiple simultaneous connections
4. Test handling of various event types (read ready, write ready, errors)
5. Stress test with many connections to verify scalability
6. Test timeout behavior and error conditions

# Subtasks:

## 1. Implement epoll abstraction \[done]

### Dependencies: None

### Description: Create the core epoll-based mechanism that will monitor file descriptors for activity

### Details:

* Use `epoll_create1()`, handle EINTR and errors
* Support both level-triggered and edge-triggered modes
* Compare performance against select()/poll() in benchmarks

## 2. Develop file descriptor registration system \[done]

### Dependencies: 2.1

### Description: Create thread-safe methods to add, modify, and remove FDs in the epoll instance

### Details:

* Wrap `epoll_ctl()` for `EPOLL_CTL_ADD`, `MOD`, `DEL`
* Validate no duplicate additions, handle invalid FDs
* Clean up resources on removal

## 3. Build event dispatching logic \[done]

### Dependencies: 2.1, 2.2

### Description: Implement the loop that calls `epoll_wait()` and dispatches callbacks

### Details:

* Process returned `epoll_event` array
* Prioritize read/write events if needed
* Integrate metrics for event processing rates

## 4. Implement timeout handling \[done]

### Dependencies: 2.3

### Description: Add support for timed operations within the epoll loop

### Details:

* Use `epoll_wait()` timeout parameter
* Integrate with a timer wheel or priority queue for scheduled callbacks
* Cancel and reschedule timers as needed

## 5. Develop callback management system \[done]

### Dependencies: 2.3, 2.4

### Description: Manage callback registration and execution within the loop

### Details:

* Queue and invoke callbacks in response to epoll events
* Handle exceptions or long-running callbacks safely
* Support callback cancellation

## 6. Implement error recovery and edge case handling \[done]

### Dependencies: 2.1, 2.2, 2.3, 2.4, 2.5

### Description: Provide robust error handling in epoll-based loop

### Details:

* Gracefully handle `EPOLLERR`, `EPOLLHUP`
* Recover from failures of `epoll_ctl()` and `epoll_wait()`
* Ensure cleanup on shutdown and resource exhaustion

