# Task ID: 3
# Title: Event Loop Implementation with I/O Multiplexing
# Status: done
# Dependencies: 2
# Priority: high
# Description: Implement a non-blocking event loop using poll(), select(), epoll(), or kqueue() to monitor multiple file descriptors for I/O events.
# Details:
Create an EventLoop class that manages the I/O multiplexing:

```cpp
class EventLoop {
private:
    std::vector<struct pollfd> _pollfds;
    std::map<int, Client*> _clients;
    std::vector<Socket*> _serverSockets;
    bool _running;
    
public:
    EventLoop();
    ~EventLoop();
    
    void addServerSocket(Socket* socket);
    void addClient(int clientFd, Client* client);
    void removeClient(int clientFd);
    void run();
    void stop();
};
```

Implementation steps:
1. Initialize poll/epoll/select data structures
2. Add server sockets to the monitored set
3. In the main loop:
   a. Wait for events with poll()/epoll_wait()/select()
   b. Handle new connections on server sockets
   c. Process I/O on client sockets
   d. Remove clients that have timed out or closed connections
4. Implement a simple timeout mechanism using timestamps

Ensure all I/O operations are non-blocking and properly handled through the event loop.

# Test Strategy:
1. Test with multiple concurrent connections
2. Verify that the server doesn't block on any single client
3. Test timeout handling by creating idle connections
4. Measure performance under load to ensure efficient event handling

# Subtasks:
## 1. Design and implement event loop data structures [done]
### Dependencies: None
### Description: Create the core data structures needed for the event loop implementation
### Details:
Define and implement the necessary data structures for the event loop, including event registration, event queue, file descriptor tracking, and callback management. Consider using appropriate data structures for efficient lookup and traversal such as hash maps for descriptor tracking and priority queues for timeout management.

## 2. Implement server socket registration mechanism [done]
### Dependencies: 3.1
### Description: Create functionality to register server sockets with the event loop
### Details:
Develop the API and implementation for registering server sockets with the event loop. This should include setting up non-blocking mode for the sockets, registering them for read events, and associating appropriate callback handlers for accept operations.

## 3. Implement event polling mechanism [done]
### Dependencies: 3.1
### Description: Create the core polling functionality using select/poll/epoll/kqueue
### Details:
Implement the event polling mechanism using the appropriate system call (select, poll, epoll on Linux, kqueue on BSD/macOS). This should efficiently wait for events on multiple file descriptors and return when activity is detected or a timeout occurs. Consider platform-specific optimizations and fallbacks.

## 4. Implement new connection handling [done]
### Dependencies: 3.2, 3.3
### Description: Create functionality to accept and set up new client connections
### Details:
Implement the logic to handle incoming connection events, accept new connections, set them to non-blocking mode, and register them with the event loop for subsequent I/O operations. Include error handling for connection failures and resource limits.

## 5. Implement client I/O processing [done]
### Dependencies: 3.4
### Description: Create read/write handlers for client socket I/O operations
### Details:
Develop the read and write event handlers for client sockets. This should include buffering mechanisms, partial read/write handling, and integration with the application logic. Ensure proper error handling for connection resets, broken pipes, and other I/O errors.

## 6. Implement timeout management system [done]
### Dependencies: 3.3
### Description: Create a system to handle operation timeouts and periodic events
### Details:
Implement a timeout management system that can efficiently track and trigger time-based events. This should include APIs for registering timeout callbacks, efficient storage and retrieval of timeout events, and integration with the main event loop to ensure timely execution without excessive polling.

## 7. Implement resource cleanup mechanisms [done]
### Dependencies: 3.4, 3.5
### Description: Create functionality to properly clean up resources when connections close
### Details:
Develop comprehensive resource cleanup mechanisms to handle connection closures, both graceful and abrupt. This should include deregistering file descriptors from the event loop, freeing associated memory, closing socket handles, and ensuring no resource leaks occur during normal operation or error conditions.

